<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aikira Terminal</title>
    <!-- Animated Favicon -->
    <link rel="icon" type="image/svg+xml" href="assets/favicon.svg">
    <style>
        /* Font faces */
        @font-face {
            font-family: 'Aikira Display';
            src: url('assets/fonts/aikira-display.ttf') format('truetype');
        }

        @font-face {
            font-family: 'Governance Text';
            src: url('assets/fonts/governance-text.ttf') format('truetype');
        }

        /* Root variables */
        :root {
            /* Pastel Color Palette */
            --soft-pink: #FFD6EC;
            --lavender-purple: #D8B5FF;
            --pastel-turquoise: #A9EEE6;
            --soft-white: #FFFFFF;
            --dark-bg: #12151a;
            --medium-bg: #1c2029;
            --light-bg: #272b36;
            
            /* Accent Colors */
            --accent-pink: #ff9ee5;
            --accent-purple: #b38aff;
            --accent-turquoise: #7adbcf;
            
            /* Transparency Values */
            --trans-light: rgba(255, 255, 255, 0.1);
            --trans-medium: rgba(255, 255, 255, 0.05);
            --trans-dark: rgba(0, 0, 0, 0.3);
            
            /* Fonts */
            --display-font: 'Aikira Display', sans-serif;
            --text-font: 'Governance Text', sans-serif;
        }

        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--soft-white);
            font-family: var(--text-font);
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        /* Main container layout */
        .aikira-container {
            display: grid;
            grid-template-rows: auto 1fr;
            grid-template-columns: 1fr 320px;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        /* Header Styles */
        .aikira-header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: var(--medium-bg);
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(216, 181, 255, 0.2);
            border: 1px solid var(--trans-light);
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .core-logo {
            height: 45px;
            width: auto;
            filter: drop-shadow(0 0 8px var(--lavender-purple));
        }

        .terminal-title {
            font-family: var(--display-font);
            color: var(--soft-pink);
            font-size: 24px;
            text-shadow: 0 0 10px rgba(255, 214, 236, 0.6);
            letter-spacing: 2px;
        }

        .status-bar {
            display: flex;
            gap: 15px;
        }

        .status-item {
            text-align: center;
            min-width: 120px;
        }

        .status-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--pastel-turquoise);
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 14px;
            color: var(--soft-white);
            background: var(--trans-medium);
            padding: 4px 8px;
            border-radius: 4px;
            border-bottom: 2px solid var(--accent-turquoise);
            transition: all 0.3s ease;
        }

        /* Main Terminal Area */
        .terminal-container {
            grid-column: 1;
            grid-row: 2;
            position: relative;
            background: var(--medium-bg);
            border-radius: 15px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--trans-light);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        /* Digital World Background */
        .digital-world-bg {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 0;
            background-image: 
                linear-gradient(rgba(169, 238, 230, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(216, 181, 255, 0.05) 1px, transparent 1px);
            background-size: 30px 30px;
            opacity: 0.5;
        }

        /* Response Area */
        .response-area {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .startup-message {
            color: var(--lavender-purple);
            text-align: center;
            font-size: 18px;
            margin: 20px auto;
            font-family: var(--display-font);
            letter-spacing: 1px;
            animation: pulse 2s infinite;
        }

        .response-text {
            font-size: 16px;
            line-height: 1.6;
            color: var(--soft-white);
            padding: 20px;
            background: rgba(28, 32, 41, 0.7);
            border-radius: 15px;
            border: 1px solid rgba(216, 181, 255, 0.3);
            box-shadow: 0 0 20px rgba(216, 181, 255, 0.2);
            position: relative;
            z-index: 1;
        }

        /* Sound Visualization */
        .sound-visualization {
            width: 100%;
            height: 60px;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }

        #voice-waveform {
            width: 100%;
            height: 100%;
            background-color: rgba(18, 21, 26, 0.5);
            border-radius: 8px;
        }

        .sound-visualization::before, .sound-visualization::after {
            content: '';
            position: absolute;
            height: 1px;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, var(--accent-purple), transparent);
            z-index: 1;
        }

        .sound-visualization::before {
            top: 0;
            animation: dataFlow 3s linear infinite;
        }

        .sound-visualization::after {
            bottom: 0;
            animation: dataFlow 3s linear reverse infinite;
        }

        /* User Input Area */
        .user-input-container {
            width: 100%;
            padding: 20px;
            margin-top: auto;
            background: var(--light-bg);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1;
            border-top: 1px solid var(--trans-light);
        }

        .input-methods {
            display: flex;
            gap: 15px;
        }

        .voice-input-btn {
            background: transparent;
            border: 2px solid var(--accent-pink);
            border-radius: 10px;
            color: var(--soft-pink);
            padding: 10px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: var(--text-font);
        }

        .voice-input-btn:hover {
            background: rgba(255, 158, 229, 0.1);
            box-shadow: 0 0 10px rgba(255, 158, 229, 0.3);
        }

        .mic-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid var(--soft-pink);
            position: relative;
        }

        .mic-icon::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 10px;
            background: var(--soft-pink);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -30%);
        }

        /* Volume Icon */
        .volume-icon {
            width: 20px;
            height: 20px;
            position: relative;
        }

        .volume-icon::before {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--soft-pink);
            left: 0;
            top: 6px;
            clip-path: polygon(0 0, 40% 0, 100% 100%, 0 100%);
        }

        .volume-icon::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid var(--soft-pink);
            border-left: none;
            border-radius: 0 12px 12px 0;
            top: 4px;
            left: 6px;
        }

        .volume-icon.muted::after {
            opacity: 0.5;
        }

        .volume-icon.muted::before {
            background: var(--accent-pink);
        }

        .volume-icon.muted span {
            position: absolute;
            width: 22px;
            height: 2px;
            background: var(--accent-pink);
            transform: rotate(45deg);
            top: 9px;
            left: -1px;
        }

        .text-input-area {
            flex: 1;
            display: flex;
            gap: 10px;
        }

        #proposal-text {
            flex: 1;
            background: var(--trans-medium);
            border: 1px solid var(--trans-light);
            border-radius: 10px;
            color: var(--soft-white);
            padding: 12px 15px;
            resize: none;
            font-family: var(--text-font);
            font-size: 14px;
            outline: none;
            transition: all 0.3s ease;
            min-height: 45px;
        }

        #proposal-text:focus {
            border-color: var(--lavender-purple);
            box-shadow: 0 0 10px rgba(216, 181, 255, 0.3);
        }

        .submit-btn {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-turquoise));
            border: none;
            border-radius: 10px;
            color: var(--soft-white);
            padding: 10px 20px;
            font-family: var(--display-font);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 1px;
        }

        .submit-btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(169, 238, 230, 0.3);
        }

        .input-status {
            font-size: 12px;
            color: var(--pastel-turquoise);
            text-align: right;
            font-style: italic;
        }

        /* Governance Panels */
        .governance-panels {
            grid-column: 2;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: var(--medium-bg);
            border-radius: 15px;
            overflow: hidden;
            border: 1px solid var(--trans-light);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .panel-title {
            background: var(--light-bg);
            padding: 15px;
            font-family: var(--display-font);
            font-size: 16px;
            color: var(--soft-pink);
            letter-spacing: 1px;
            border-bottom: 1px solid var(--trans-light);
        }

        .panel-content {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }

        /* Evaluation Metrics */
        .evaluation-metrics {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .metric {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .metric-label {
            font-size: 14px;
            color: var(--lavender-purple);
        }

        .metric-bar {
            height: 8px;
            background: var(--trans-medium);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .metric-value {
            height: 100%;
            border-radius: 4px;
            background: linear-gradient(90deg, var(--accent-turquoise), var(--accent-purple));
            width: 0%;
            transition: width 1s ease-in-out;
        }

        /* Consensus Visualization */
        .consensus-visualization {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
            justify-content: center;
            padding: 20px 0;
        }

        .consensus-label {
            font-size: 14px;
            color: var(--accent-turquoise);
            margin-bottom: 15px;
            text-align: center;
        }

        .consensus-triangle {
            width: 180px;
            height: 160px;
            position: relative;
            margin: 0 auto;
        }

        .triangle-shape {
            width: 100%;
            height: 100%;
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            background: linear-gradient(180deg, var(--lavender-purple), var(--pastel-turquoise));
            opacity: 0.6;
        }

        .consensus-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
            z-index: 10;
        }

        .consensus-value {
            text-align: center;
            font-size: 24px;
            font-family: var(--display-font);
            color: var(--soft-white);
            margin-top: 20px;
        }

        /* Particle styles */
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: var(--accent-turquoise);
            border-radius: 50%;
            opacity: 0.5;
            pointer-events: none;
            animation: float 8s infinite linear;
        }

        /* Volume Slider */
        .volume-slider-container {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background: var(--medium-bg);
            border: 1px solid var(--trans-light);
            border-radius: 10px;
            padding: 10px;
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .volume-slider-container.visible {
            display: flex;
        }

        #volume-slider {
            width: 150px;
            -webkit-appearance: none;
            height: 6px;
            background: var(--trans-light);
            border-radius: 3px;
            outline: none;
        }

        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-pink);
            cursor: pointer;
        }

        #volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-pink);
            cursor: pointer;
            border: none;
        }

        .volume-value {
            color: var(--soft-white);
            font-size: 12px;
            text-align: center;
        }

        /* Debug panel */
        .debug-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            font-family: monospace;
            padding: 5px;
            font-size: 12px;
            z-index: 9999;
            max-width: 300px;
            max-height: 100px;
            overflow: auto;
            border: 1px solid #333;
            display: none;
        }

        /* Animations */
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        @keyframes dataFlow {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes float {
            0% {
                transform: translateY(0) translateX(0);
                opacity: 0;
            }
            10% {
                opacity: 0.5;
            }
            90% {
                opacity: 0.5;
            }
            100% {
                transform: translateY(-100px) translateX(50px);
                opacity: 0;
            }
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .aikira-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .governance-panels {
                grid-column: 1;
                grid-row: 3;
            }
            
            .terminal-container {
                height: 60vh;
            }
        }

        @media (max-width: 768px) {
            .aikira-header {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
            }
            
            .status-bar {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .input-methods {
                flex-direction: column;
            }
            
            .voice-input-btn {
                align-self: flex-start;
            }
        }
    </style>
</head>
<body>
    <!-- Debug panel for audio troubleshooting -->
    <div class="debug-panel" id="debug-panel"></div>

    <div class="aikira-container">
        <!-- Header Section -->
        <header class="aikira-header">
            <div class="logo-container">
                <!-- Updated to use the animated core logo -->
                <img src="assets/images/aikira-core.svg" alt="Aikira Core" class="core-logo">
                <h1 class="terminal-title">AIKIRA TERMINAL</h1>
            </div>
            <div class="status-bar">
                <div class="status-item" id="constitutional-alignment">
                    <div class="status-label">Constitutional Alignment</div>
                    <div class="status-value" style="border-color: var(--accent-turquoise);">Initializing...</div>
                </div>
                <div class="status-item" id="proposal-evaluation">
                    <div class="status-label">Proposal Evaluation</div>
                    <div class="status-value" style="border-color: var(--accent-purple);">Ready</div>
                </div>
                <div class="status-item" id="voice-authentication">
                    <div class="status-label">Voice Authentication</div>
                    <div class="status-value" style="border-color: var(--accent-pink);">Standby</div>
                </div>
                <div class="status-item" id="consensus-index">
                    <div class="status-label">Consensus Index</div>
                    <div class="status-value" style="border-color: var(--accent-turquoise);">92%</div>
                </div>
                <div class="status-item" id="governance-notices">
                    <div class="status-label">Governance Notices</div>
                    <div class="status-value" style="border-color: var(--accent-purple);">0</div>
                </div>
            </div>
        </header>

        <!-- Main Terminal Area -->
        <main class="terminal-container">
            <!-- Digital World Background -->
            <div class="digital-world-bg">
                <!-- Floating particles will be added here via JS -->
            </div>

            <!-- Response Area -->
            <div class="response-area">
                <div class="response-text" id="response-text">
                    Aikira Constitutional AI Core initialized. How may I assist you today?
                </div>
                <div class="sound-visualization">
                    <canvas id="voice-waveform"></canvas>
                </div>
            </div>

            <!-- User Input Area -->
            <div class="user-input-container">
                <div class="input-methods">
                    <button class="voice-input-btn" id="voice-input-btn">
                        <div class="mic-icon"></div>
                        <span>Voice Input</span>
                    </button>
                    <button class="voice-input-btn" id="volume-btn">
                        <div class="volume-icon"></div>
                        <span>Volume</span>
                    </button>
                    <div class="text-input-area">
                        <textarea id="proposal-text" placeholder="Enter your governance proposal here..."></textarea>
                        <button id="submit-proposal" class="submit-btn">Submit</button>
                    </div>
                </div>
                <div class="input-status" id="input-status">Ready for input</div>
            </div>

            <!-- Volume Slider (Hidden by default) -->
            <div class="volume-slider-container" id="volume-slider-container">
                <input type="range" min="0" max="100" value="80" id="volume-slider">
                <div class="volume-value" id="volume-value">Volume: 80%</div>
            </div>
        </main>

        <!-- Governance Panels -->
        <aside class="governance-panels">
            <!-- Proposal Evaluation Panel -->
            <div class="panel" id="evaluation-panel">
                <div class="panel-title">Proposal Evaluation</div>
                <div class="panel-content">
                    <div class="evaluation-metrics">
                        <div class="metric">
                            <div class="metric-label">Fairness Index:</div>
                            <div class="metric-bar">
                                <div class="metric-value" style="width: 80%"></div>
                            </div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Value Alignment:</div>
                            <div class="metric-bar">
                                <div class="metric-value" style="width: 75%"></div>
                            </div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Protection Score:</div>
                            <div class="metric-bar">
                                <div class="metric-value" style="width: 90%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Consensus Visualization Panel -->
            <div class="panel" id="consensus-panel">
                <div class="panel-title">Consensus Visualization</div>
                <div class="panel-content">
                    <div class="consensus-visualization">
                        <div class="consensus-label">Consensus Index</div>
                        <div class="consensus-triangle">
                            <div class="triangle-shape"></div>
                            <div class="consensus-indicator"></div>
                        </div>
                        <div class="consensus-value">92%</div>
                    </div>
                </div>
            </div>
        </aside>
    </div>

    <!-- Audio Elements -->
    <audio id="startup-sound" src="assets/audio/startup.mp3" preload="auto"></audio>
    <audio id="deliberation-sound" src="assets/audio/deliberation.mp3" preload="auto"></audio>
    <audio id="proposal-submit-sound" src="assets/audio/proposal-submit.mp3" preload="auto"></audio>
    <audio id="governance-alert-sound" src="assets/audio/governance-alert.mp3" preload="auto"></audio>

    <!-- Scripts -->
    <script src="lib/three.min.js"></script>
    <script src="lib/p5.min.js"></script>
    <script src="lib/gsap.min.js"></script>
    <script src="js/audio-controls.js"></script>
    
    <script>
        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Show debug panel
            const debugPanel = document.getElementById('debug-panel');
            debugPanel.style.display = 'block';
            
            // Add debug message function
            window.debugLog = function(message) {
                if (debugPanel) {
                    const logItem = document.createElement('div');
                    logItem.textContent = message;
                    debugPanel.appendChild(logItem);
                    
                    // Scroll to bottom
                    debugPanel.scrollTop = debugPanel.scrollHeight;
                    
                    // Limit log entries
                    if (debugPanel.children.length > 20) {
                        debugPanel.removeChild(debugPanel.firstChild);
                    }
                }
                
                // Also log to console
                console.log(message);
            };
            
            // Initialize audio functionality
            initAudioControls();
            
            // Initialize the rest of your application
            initializeUI();
            
            // Set up event listeners for user interactions
            setupEventListeners();
        });
        
        // Initialize audio controls
        function initAudioControls() {
            debugLog('Initializing audio controls');
            
            const volumeBtn = document.getElementById('volume-btn');
            const volumeSliderContainer = document.getElementById('volume-slider-container');
            const volumeSlider = document.getElementById('volume-slider');
            const volumeValue = document.getElementById('volume-value');
            
            // Create audio context
            try {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                window.audioContext = new AudioContext();
                debugLog('Audio Context created: ' + window.audioContext.state);
            } catch (e) {
                debugLog('Error creating Audio Context: ' + e.message);
            }
            
            // Track mute state
            let isMuted = false;
            let lastVolume = 0.8; // Default 80%
            
            // Show/hide volume slider and toggle mute
            volumeBtn.addEventListener('click', function() {
                debugLog('Volume button clicked');
                
                // Toggle slider visibility
                if (volumeSliderContainer.classList.contains('visible')) {
                    // Already visible, toggle mute
                    isMuted = !isMuted;
                    
                    if (isMuted) {
                        // Store current volume before muting
                        if (parseFloat(volumeSlider.value) > 0) {
                            lastVolume = parseFloat(volumeSlider.value) / 100;
                        }
                        
                        // Set slider to 0
                        volumeSlider.value = 0;
                        volumeValue.textContent = 'Volume: 0%';
                        
                        // Update volume icon
                        const volumeIcon = volumeBtn.querySelector('.volume-icon');
                        volumeIcon.classList.add('muted');
                        if (!volumeIcon.querySelector('span')) {
                            const muteSlash = document.createElement('span');
                            volumeIcon.appendChild(muteSlash);
                        }
                        
                        // Update all audio elements
                        updateAudioVolume(0);
                        debugLog('Audio muted');
                    } else {
                        // Restore previous volume
                        const restoredValue = Math.round(lastVolume * 100);
                        volumeSlider.value = restoredValue;
                        volumeValue.textContent = `Volume: ${restoredValue}%`;
                        
                        // Update volume icon
                        const volumeIcon = volumeBtn.querySelector('.volume-icon');
                        volumeIcon.classList.remove('muted');
                        const muteSlash = volumeIcon.querySelector('span');
                        if (muteSlash) muteSlash.remove();
                        
                        // Update all audio elements
                        updateAudioVolume(lastVolume);
                        debugLog('Audio unmuted: ' + lastVolume);
                    }
                } else {
                    // Show volume slider
                    volumeSliderContainer.classList.add('visible');
                    
                    // Auto-hide after 5 seconds
                    setTimeout(() => {
                        volumeSliderContainer.classList.remove('visible');
                    }, 5000);
                }
            });
            
            // Update volume when slider changes
            volumeSlider.addEventListener('input', function() {
                const volume = this.value / 100;
                volumeValue.textContent = `Volume: ${this.value}%`;
                
                // Update all audio elements
                updateAudioVolume(volume);
                debugLog('Volume changed: ' + volume);
                
                // Update mute state and icon
                const volumeIcon = volumeBtn.querySelector('.volume-icon');
                
                if (volume > 0 && isMuted) {
                    isMuted = false;
                    volumeIcon.classList.remove('muted');
                    const muteSlash = volumeIcon.querySelector('span');
                    if (muteSlash) muteSlash.remove();
                } else if (volume === 0 && !isMuted) {
                    isMuted = true;
                    volumeIcon.classList.add('muted');
                    if (!volumeIcon.querySelector('span')) {
                        const muteSlash = document.createElement('span');
                        volumeIcon.appendChild(muteSlash);
                    }
                }
                
                // Store non-zero volume
                if (volume > 0) {
                    lastVolume = volume;
                }
            });
            
            // Initialize audio on first user interaction
            document.addEventListener('click', function() {
                debugLog('User interaction - initializing audio');
                
                if (window.audioContext && window.audioContext.state === 'suspended') {
                    window.audioContext.resume().then(() => {
                        debugLog('Audio Context resumed: ' + window.audioContext.state);
                        
                        // Play startup sound
                        playTestSound();
                    }).catch(e => {
                        debugLog('Error resuming Audio Context: ' + e.message);
                    });
                } else {
                    debugLog('Audio Context already running or not available');
                    
                    // Play startup sound anyway
                    playTestSound();
                }
            }, { once: true });
            
            // Play a test sound to verify audio is working
            function playTestSound() {
                try {
                    const startupSound = document.getElementById('startup-sound');
                    if (startupSound) {
                        startupSound.volume = volumeSlider.value / 100;
                        debugLog('Playing startup sound (volume: ' + startupSound.volume + ')');
                        
                        // Add event listeners for monitoring
                        startupSound.addEventListener('playing', () => {
                            debugLog('Startup sound is playing');
                        });
                        
                        startupSound.addEventListener('ended', () => {
                            debugLog('Startup sound ended');
                        });
                        
                        startupSound.addEventListener('error', (e) => {
                            debugLog('Startup sound error: ' + e.type);
                        });
                        
                        // Play the sound
                        startupSound.play().then(() => {
                            debugLog('Startup sound playback started');
                        }).catch(e => {
                            debugLog('Startup sound playback error: ' + e.message);
                        });
                    } else {
                        debugLog('Startup sound element not found');
                    }
                } catch (e) {
                    debugLog('Error playing test sound: ' + e.message);
                }
            }
        }
        
        // Update volume for all audio elements
        function updateAudioVolume(volume) {
            // Update HTML audio elements
            const audioElements = document.querySelectorAll('audio');
            audioElements.forEach(audio => {
                audio.volume = volume;
            });
            
            // Update audio processor if available
            if (window.audioProcessor && window.audioProcessor.gainNode) {
                window.audioProcessor.setVolume(volume);
            }
            
            // Store in localStorage for persistence
            localStorage.setItem('aikiraVolume', volume);
        }
        
        // Play audio with robust error handling
        function playAudio(src) {
            debugLog('Attempting to play audio: ' + src);
            
            try {
                // Check if audio file exists (indirectly)
                fetch(src, { method: 'HEAD' })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Audio file not found: ${response.status}`);
                        }
                        
                        // Create or reuse audio element
                        const audio = new Audio(src);
                        
                        // Set volume based on slider
                        const volumeSlider = document.getElementById('volume-slider');
                        if (volumeSlider) {
                            audio.volume = volumeSlider.value / 100;
                            debugLog('Setting volume to: ' + audio.volume);
                        }
                        
                        // Add event listeners for debugging
                        audio.addEventListener('playing', () => {
                            debugLog('Audio started playing: ' + src);
                        });
                        
                        audio.addEventListener('ended', () => {
                            debugLog('Audio finished: ' + src);
                        });
                        
                        audio.addEventListener('error', (e) => {
                            debugLog('Audio error: ' + e.type);
                            document.getElementById('input-status').textContent = 'Audio Error';
                        });
                        
                        // Play audio with more detailed error handling
                        audio.play().catch(e => {
                            debugLog('Audio play error: ' + e.message);
                            document.getElementById('input-status').textContent = 'Audio Error: ' + e.message;
                        });
                    })
                    .catch(error => {
                        debugLog('Fetch error for audio: ' + error.message);
                        document.getElementById('input-status').textContent = 'Audio Error: File Not Found';
                    });
            } catch (e) {
                debugLog('Audio play exception: ' + e.message);
                document.getElementById('input-status').textContent = 'Audio Error: ' + e.message;
            }
        }
        
        // Initialize UI elements and animations
        function initializeUI() {
            debugLog('Initializing UI');
            
            // Create floating particles
            createParticles();
            
            // Set up waveform visualization
            initializeWaveform();
            
            // Animate initial metrics
            animateMetrics();
        }
        
        // Set up event listeners
        function setupEventListeners() {
            debugLog('Setting up event listeners');
            
            // Get DOM elements
            const submitButton = document.getElementById('submit-proposal');
            const proposalText = document.getElementById('proposal-text');
            const voiceButton = document.getElementById('voice-input-btn');
            
            // Add event listener for proposal submission
            if (submitButton && proposalText) {
                submitButton.addEventListener('click', function() {
                    const proposal = proposalText.value.trim();
                    if (proposal) {
                        processProposal(proposal);
                    }
                });
                
                // Allow submission using Enter key (Shift+Enter for new line)
                proposalText.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        submitButton.click();
                    }
                });
            }
            
            // Add event listener for voice input
            if (voiceButton) {
                voiceButton.addEventListener('click', function() {
                    debugLog('Voice button clicked');
                    
                    // Toggle active state
                    this.classList.toggle('active');
                    
                    if (this.classList.contains('active')) {
                        // Start voice recording
                        document.getElementById('input-status').textContent = 'Listening...';
                        
                        // Animate waveform
                        animateActiveWaveform(true);
                        
                        // Play sound
                        playAudio('assets/audio/proposal-submit.mp3');
                        
                        // Actually start recording
                        startVoiceRecording();
                    } else {
                        stopVoiceRecording();
                    }
                });
            }
        }
        
        // Start voice recording
        function startVoiceRecording() {
            debugLog('Starting voice recording');
            
            try {
                // Request microphone access
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        debugLog('Microphone access granted');
                        
                        // Create media recorder
                        window.mediaRecorder = new MediaRecorder(stream);
                        window.audioChunks = [];
                        
                        // Add data handler
                        window.mediaRecorder.addEventListener('dataavailable', event => {
                            window.audioChunks.push(event.data);
                        });
                        
                        // Add stop handler
                        window.mediaRecorder.addEventListener('stop', () => {
                            debugLog('Recording stopped');
                            
                            // Create blob from chunks
                            const audioBlob = new Blob(window.audioChunks, { type: 'audio/wav' });
                            
                            // Send to server for transcription
                            transcribeAudio(audioBlob);
                        });
                        
                        // Start recording
                        window.mediaRecorder.start();
                        debugLog('Recording started');
                        
                        // Automatically stop after 10 seconds as safety
                        setTimeout(() => {
                            if (window.mediaRecorder && window.mediaRecorder.state === 'recording') {
                                stopVoiceRecording();
                            }
                        }, 10000);
                    })
                    .catch(error => {
                        debugLog('Microphone access denied: ' + error.message);
                        document.getElementById('input-status').textContent = 'Error: Microphone access denied';
                        document.getElementById('voice-input-btn').classList.remove('active');
                        animateActiveWaveform(false);
                    });
            } catch (error) {
                debugLog('Voice recording error: ' + error.message);
                document.getElementById('input-status').textContent = 'Error: ' + error.message;
                document.getElementById('voice-input-btn').classList.remove('active');
                animateActiveWaveform(false);
            }
        }
        
        // Stop voice recording
        function stopVoiceRecording() {
            debugLog('Stopping voice recording');
            
            document.getElementById('input-status').textContent = 'Processing voice input...';
            animateActiveWaveform(false);
            
            // Stop the recorder
            if (window.mediaRecorder && window.mediaRecorder.state === 'recording') {
                window.mediaRecorder.stop();
                
                // Stop microphone access
                window.mediaRecorder.stream.getTracks().forEach(track => track.stop());
            } else {
                debugLog('No active media recorder to stop');
                document.getElementById('input-status').textContent = 'Error: No active recording';
            }
        }
        
        // Transcribe audio using server API
        function transcribeAudio(audioBlob) {
            debugLog('Transcribing audio');
            
            // Create form data for upload
            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.wav');
            
            // Send to server
            fetch('/api/speech/transcribe', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Server error: ' + response.status);
                }
                return response.json();
            })
            .then(data => {
                if (data.success && data.text) {
                    debugLog('Transcription successful: ' + data.text);
                    
                    // Process the transcribed text
                    processProposal(data.text);
                } else {
                    debugLog('Transcription failed - no text received');
                    document.getElementById('input-status').textContent = 'Error: Transcription failed';
                }
            })
            .catch(error => {
                debugLog('Transcription error: ' + error.message);
                document.getElementById('input-status').textContent = 'Error: ' + error.message;
                
                // Show static error message instead of fallback
                typeText(document.getElementById('response-text'), 
                    "I'm sorry, but I couldn't transcribe your voice input. There was an error: " + error.message);
            });
        }
        
        // Process proposal
        function processProposal(proposalText) {
            debugLog('Processing proposal: ' + proposalText);
            
            // Update status
            document.getElementById('input-status').textContent = 'Processing proposal...';
            
            // Clear input
            document.getElementById('proposal-text').value = '';
            
            // Play sound
            playAudio('assets/audio/deliberation.mp3');
            
            // Send to API
            fetch('/api/proposal/evaluate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ proposal: proposalText })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Server error: ' + response.status);
                }
                return response.json();
            })
            .then(data => {
                if (data.success && data.result) {
                    debugLog('Proposal evaluation successful');
                    
                    // Update response text with typing effect
                    typeText(document.getElementById('response-text'), data.result.response);
                    
                    // Update metrics
                    updateMetrics(
                        Math.round(data.result.scores.fairness * 100),
                        Math.round(data.result.scores.value * 100),
                        Math.round(data.result.scores.protection * 100),
                        Math.round(data.result.consensusIndex * 100)
                    );
                    
                    // Update status
                    document.getElementById('input-status').textContent = 'Ready for input';
                    
                    // Play response audio
                    playAudio('assets/audio/deliberation.mp3');
                } else {
                    throw new Error('Invalid response format');
                }
            })
            .catch(error => {
                debugLog('Proposal processing error: ' + error.message);
                document.getElementById('input-status').textContent = 'Error: ' + error.message;
                
                // Fallback to simulated response for demo
                simulateProposalResponse(proposalText);
            });
        }
        
        // Simulate proposal response for demo/testing
        function simulateProposalResponse(proposalText) {
            debugLog('Using simulated proposal response');
            
            // Sample response
            const response = "After constitutional analysis, I've determined that your proposal aligns well with our governance principles. The value generation aspects are particularly strong. However, there is room to improve consensus alignment. Consider enhancing the fairness distribution framework.";
            
            // Update response text with typing effect
            typeText(document.getElementById('response-text'), response);
            
            // Update metrics
            updateMetrics(78, 85, 90, 84);
            
            // Update status
            document.getElementById('input-status').textContent = 'Ready for input';
            
            // Play response audio
            playAudio('assets/audio/deliberation.mp3');
        }
        
        // Create particles
        function createParticles() {
            const container = document.querySelector('.digital-world-bg');
            if (!container) return;
            
            const colors = ['var(--soft-pink)', 'var(--lavender-purple)', 'var(--pastel-turquoise)'];
            
            // Create 20 particles
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                
                // Random position
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.top = `${Math.random() * 100}%`;
                
                // Random color and size
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.width = `${Math.random() * 3 + 2}px`;
                particle.style.height = `${Math.random() * 3 + 2}px`;
                
                // Random animation delay
                particle.style.animationDelay = `${Math.random() * 8}s`;
                
                container.appendChild(particle);
            }
        }
        
        // Initialize waveform visualization
        function initializeWaveform() {
            const canvas = document.getElementById('voice-waveform');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Draw a subtle idle waveform
            function drawIdleWave() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'rgba(28, 32, 41, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const centerY = canvas.height / 2;
                
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                
                // Draw a gentle sine wave
                for (let x = 0; x < canvas.width; x++) {
                    const amplitude = 5 + Math.sin(Date.now() * 0.001) * 2;
                    const y = centerY + Math.sin(x * 0.05 + Date.now() * 0.001) * amplitude;
                    ctx.lineTo(x, y);
                }
                
                ctx.strokeStyle = 'rgba(169, 238, 230, 0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                requestAnimationFrame(drawIdleWave);
            }
            
            drawIdleWave();
        }
        
        // Animate active waveform
        function animateActiveWaveform(isActive) {
            const canvas = document.getElementById('voice-waveform');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            if (isActive) {
                // Store the animation frame ID to cancel it later
                window.activeWaveformAnimationId = requestAnimationFrame(function animateFrame() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'rgba(28, 32, 41, 0.8)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const centerY = canvas.height / 2;
                    
                    // Draw a more active waveform
                    ctx.beginPath();
                    ctx.moveTo(0, centerY);
                    
                    for (let x = 0; x < canvas.width; x++) {
                        // More dynamic wave with multiple frequencies
                        const y = centerY + 
                            Math.sin(x * 0.05 + Date.now() * 0.002) * 10 + 
                            Math.sin(x * 0.02 + Date.now() * 0.001) * 5;
                        ctx.lineTo(x, y);
                    }
                    
                    // Gradient stroke
                    const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                    gradient.addColorStop(0, 'rgba(255, 214, 236, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(216, 181, 255, 0.8)');
                    gradient.addColorStop(1, 'rgba(169, 238, 230, 0.8)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Continue animation
                    if (document.querySelector('.voice-input-btn.active')) {
                        window.activeWaveformAnimationId = requestAnimationFrame(animateFrame);
                    }
                });
            } else {
                // Cancel active animation
                if (window.activeWaveformAnimationId) {
                    cancelAnimationFrame(window.activeWaveformAnimationId);
                }
            }
        }
        
        // Animate metrics
        function animateMetrics() {
            // Get metric elements
            const metricBars = document.querySelectorAll('.metric-value');
            
            // Animate metrics after a short delay
            setTimeout(() => {
                metricBars.forEach(metric => {
                    // Get the current width from the style
                    const width = metric.style.width;
                    // Reset to 0 and then animate to the target width
                    metric.style.width = '0%';
                    setTimeout(() => {
                        metric.style.width = width;
                    }, 300);
                });
            }, 800);
        }
        
        // Update metrics
        function updateMetrics(fairness, value, protection, consensus) {
            debugLog(`Updating metrics - F: ${fairness}, V: ${value}, P: ${protection}, C: ${consensus}`);
            
            // Get metric elements
            const metricBars = document.querySelectorAll('.metric-value');
            
            // Update metrics bars with animation
            if (metricBars.length >= 3) {
                // Reset before animating
                metricBars.forEach(bar => {
                    bar.style.width = '0%';
                });
                
                // Animate after a short delay
                setTimeout(() => {
                    metricBars[0].style.width = `${fairness}%`;
                    metricBars[1].style.width = `${value}%`;
                    metricBars[2].style.width = `${protection}%`;
                }, 300);
            }
            
            // Update consensus value
            const consensusValueEl = document.querySelector('.consensus-value');
            if (consensusValueEl) {
                consensusValueEl.textContent = `${consensus}%`;
            }
            
            // Update status bar consensus
            const consensusStatusEl = document.querySelector('#consensus-index .status-value');
            if (consensusStatusEl) {
                consensusStatusEl.textContent = `${consensus}%`;
            }
            
            // Update triangle visualization
            updateConsensusTriangle(consensus / 100);
        }
        
        // Update consensus triangle visualization
        function updateConsensusTriangle(consensusValue) {
            const indicator = document.querySelector('.consensus-indicator');
            if (!indicator) return;
            
            const triangle = document.querySelector('.consensus-triangle');
            if (!triangle) return;
            
            // Triangle dimensions
            const height = triangle.offsetHeight;
            const width = triangle.offsetWidth;
            
            // Calculate position (higher consensus = higher position)
            const yPos = height - (consensusValue * height * 0.8); // Leave some space at top/bottom
            const xPos = width / 2; // Center horizontally
            
            // Update indicator position
            indicator.style.top = `${yPos}px`;
            indicator.style.left = `${xPos}px`;
        }
        
        // Text typing effect
        function typeText(element, text, speed = 30) {
            if (!element) return;
            
            // Clear the element
            element.textContent = '';
            let i = 0;
            
            function type() {
                if (i < text.length) {
                    element.textContent += text.charAt(i);
                    i++;
                    setTimeout(type, speed);
                }
            }
            
            // Start typing
            type();
        }
    </script>
</body>
</html>